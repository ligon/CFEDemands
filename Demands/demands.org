:SETUP:
#+TITLE: Code and Methods for Computing Constant Frisch Elasticity Demand Systems
#+AUTHOR: Ethan Ligon
#+OPTIONS: toc:nil
#+PROPERTY: header-args:python :results output :noweb no-export :exports code :comments link :prologue (format "# Tangled on %s" (current-time-string))
#+LATEX_HEADER: \renewcommand{\vec}[1]{\boldsymbol{#1}}
#+LATEX_HEADER: \newcommand{\T}{\top}
#+LATEX_HEADER: \newcommand{\E}{\ensuremath{\mbox{E}}}
#+LATEX_HEADER: \newcommand{\R}{\ensuremath{\mathbb{R}}}
#+LATEX_HEADER: \newcommand{\Cov}{\ensuremath{\mbox{Cov}}}
#+LATEX_HEADER: \newcommand{\Eq}[1]{(\ref{eq:#1})}
#+LATEX_HEADER: \newcommand{\Fig}[1]{Figure \ref{fig:#1}} \newcommand{\Tab}[1]{Table \ref{tab:#1}}
#+LATEX_HEADER: \addbibresource{main.bib}\renewcommand{\refname}{}
#+LATEX_HEADER: \addbibresource{ligon.bib}
#+LATEX_HEADER: \usepackage{stringstrings}\renewcommand{\cite}[1]{\caselower[q]{#1}\citet{\thestring}}
:END:

* Top-level demand interface

Dependencies:
 - demands ::
     - frischian
     - hicksian
     - marshallian
     - _core.lambdavalue
     - _core.relative_risk_aversion
     - _core.excess_expenditures
     - _core.excess_expenditures_derivative
     - _core.excess_utility
     - _core.lambdaforU
     - _core.expenditures
     - _utils.derivative
     - numpy.log
     - numpy.array
 - _core :: 
     - frischian 
     - hicksian.expenditures 
     - marshallian.demand
     - _utils.check_args
 - _utils ::
     - root_with_precision
 - frischian ::
     - _utils.check_args
 - marshallian ::
     - _utils.check_args
     - _core.lambdavalue
     - _utils.derivative

#+name: demands
#+BEGIN_SRC python :tangle ../cfe/demands.py
from __future__ import print_function
from . import frischian
from . import hicksian
from . import marshallian
from ._core import lambdavalue, relative_risk_aversion, excess_expenditures, excess_expenditures_derivative, excess_utility, lambdaforU, expenditures
from ._utils import derivative, check_args
from numpy import array, log

def utility(x,alpha,beta,phi):
    """
    Direct utility from consumption of x.
    """
    n,alpha,beta,phi = check_args(alpha=alpha,beta=beta,phi=phi)

    U=0
    for i in range(n):
        if beta[i]==1:
            U += alpha[i]*log(x[i]+phi[i])
        else:
            U += alpha[i]*((x[i]+phi[i])**(1-1./beta[i])-1)*beta[i]/(beta[i]-1)

    return U

def marginal_utilities(x,alpha,beta,phi):
    """
    Marginal utilities from consumption of x.
    """
    n,alpha,beta,phi = check_args(alpha=alpha,beta=beta,phi=phi)

    MU=[]
    for i in range(n):
        MU += [alpha[i]*((x[i]+phi[i])**(-1./beta[i]))]

    return MU
    
#+END_SRC
   
* Core routines
#+name: demand_core
#+BEGIN_SRC python :tangle ../cfe/_core.py
from . import frischian
from ._utils import check_args, derivative
import warnings
from numpy import nan, Inf, array
from .root_with_precision import root_with_precision

def excess_expenditures(y,p,alpha,beta,phi,NegativeDemands=True):
    """
    Return a function which will tell excess expenditures associated with a lambda.
    """
    n,alpha,beta,phi = check_args(p=p,alpha=alpha,beta=beta,phi=phi)

    def f(lbda):
        lbda=abs(lbda)

        x=frischian.demands(lbda,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

        d=0.0
        for i in range(n):
            d += x[i]*p[i]

        return d - y

    return f

def excess_expenditures_derivative(p,alpha,beta,phi):
    """
    Return derivative of excess expenditures function with respect to lambda
    """
    n,alpha,beta,phi = check_args(p,alpha,beta,phi)
    n = len(p)
    d=beta

    def df(lbda):

        lbda=abs(lbda)
        y=0.0
        for i in range(n):
            y += -d[i]*p[i]*(alpha[i]/(p[i]))**(d[i])*lbda**-(1+d[i])

        return y 

    return df

def excess_utility(U,p,alpha,beta,phi,NegativeDemands=True):
    """
    Return a function which will tell excess utility associated with a lambda.
    """

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)
    n = len(p)
    def f(lbda):

        return U - frischian.V(lbda,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    return f

def lambdavalue(y,p,alpha,beta,phi,NegativeDemands=True,ub=10,method='root_with_precision',tol=1e-12):
    """
    Given income y, prices p and preference parameters
    (alpha,beta,phi), find the marginal utility of income lbda.
    """

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    if NegativeDemands:
        subsistence=sum([p[i]*phi[i] for i in range(n)])
    else:
        subsistence=sum([p[i]*phi[i] for i in range(n) if phi[i]<0])
    
    if y+subsistence<0: # Income too low to satisfy subsistence demands
        warnings.warn('Income too small to cover subsistence phis (%f < %f)' % (y,subsistence))
        return nan

    f = excess_expenditures(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    if method=='bisect':
        try:
            return optimize.bisect(f,tol,ub)
        except ValueError:
            return lambdavalue(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands,ub=ub*2.0)
    elif method=='newton':
        df = excess_expenditures_derivative(p,alpha,beta,phi)
        return optimize.newton(f,ub/2.,fprime=df)
    elif method=='root_with_precision':
        return root_with_precision(f,[0,ub,Inf],tol,open_interval=True)
    else:
        raise ValueError("Method not defined.")

def lambdaforU(U,p,alpha,beta,phi,NegativeDemands=True,ub=10):
    """
    Given level of utility U, prices p, and preference parameters
    (alpha,beta,phi), find the marginal utility of income lbda.
    """

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    f = excess_utility(U,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    # Our root-finder looks within an interval [1e-20,ub].  If root
    # isn't in this interval, optimize.bisect will raise a ValueError;
    # in this case, try again, but with a larger upper bound.
    try:
        #return optimize.bisect(f,1e-20,ub)
        return root_with_precision(f,[0,ub,Inf],1e-12,open_interval=True)
    except ValueError:
        return lambdaforU(U,p,alpha,beta,phi,NegativeDemands=True,ub=ub*2.0)

def expenditures(lbda,p,alpha,beta,phi,NegativeDemands=True):
    # See https://gist.github.com/datagrok/40bf84d5870c41a77dc6 for this import rationale
    from .hicksian import expenditurefunction

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    U=frischian.indirect_utility(lbda,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    return expenditurefunction(U,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

def relative_risk_aversion0(p,alpha,beta,phi,NegativeDemands=True,ub=10,method='root_with_precision'):
    """
    Generates function describing (minus) elasticity of lambda w.r.t. expenditures x.

    NB: This is also relative risk aversion.

    DEPRECATED: This has been replaced by a more analytical solution, _core.relative_risk_aversion.
    """
    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    lmbda=lambda x: lambdavalue(x,p,alpha,beta,phi,NegativeDemands=True,ub=10,method='root_with_precision')
    dl=derivative(lmbda)

    def rra(x):
        return -dl(x)/lmbda(x)*x

    return rra

def relative_risk_aversion(p,alpha,beta,phi,NegativeDemands=True):
    """
    Generates function describing (minus) elasticity of lambda w.r.t. expenditures x.

    NB: This is also relative risk aversion.
    """
    from .marshallian import demands as mdemands
    
    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    def rra(x):
        return x/(array(mdemands(x,p,alpha,beta,phi,NegativeDemands=NegativeDemands))*p).dot(beta)

    return rra


#+END_SRC

** Test of RRA
#+begin_src python
  
#+end_src

* Utility and optimization routines
#+name: demand_utils
#+BEGIN_SRC python :tangle ../cfe/_utils.py
from scipy import optimize 
from numpy import array, ones, zeros, sum, log, Inf, dot, nan, all, max, abs
import warnings

def check_args(p=None,alpha=None,beta=None,phi=None,tol=1e-12):
    """
    Perform sanity check on inputs.  Supply default values if these are missing.
    """

    N = []
    # Make sure all args are of type array:
    if p is not None:
        p=array(p,dtype=float)
        N.append(len(p))

    try: 
        len(alpha) # If len() not defined, then must be a singleton
        alpha=array(alpha,dtype=float)
        N.append(len(alpha))
    except TypeError: alpha=array([alpha],dtype=float)

    try:
        len(beta) # If len() not defined, then must be a singleton
        beta = array(beta,dtype=float)
        N.append(len(beta))
    except TypeError: beta = array([beta],dtype=float)

    try:
        len(phi) # If len() not defined, then must be a singleton
        phi=array(phi,dtype=float)
        N.append(len(phi))
    except TypeError: phi=array([phi],dtype=float)

    n = max(N)

    if len(alpha)==1<n:
        alpha=ones(n)*alpha
    else:
        if not alpha.all():
            raise ValueError

    if len(beta)==1<n:
        beta = ones(n)*beta
    else:
        if not beta.all():
            raise ValueError("Problem with beta?")
        if not all(beta>0):
            beta = abs(beta*(beta>0)) + (beta<=0)*tol
            warnings.warn('Setting negative values of beta to zero.')
            #raise ValueError("Non-positive beta?")
    
    if len(phi)==1<n:
        phi=ones(n)*phi

    return (n,alpha,beta,phi)

def derivative(f,h=2e-5,LIMIT=False):
    """
    Computes the numerical derivative of a function with a single scalar argument.

    - h :: A precision parameter.  

    BUGS: Would be better to actually take a limit, instead of assuming that h 
    is infinitesimal.  
    """
    def df(x, h=h):
        return ( f(x+h/2) - f(x-h/2) )/h
    return df
#+END_SRC

* Frischian demand interface
#+name: frischian
#+BEGIN_SRC python :tangle ../cfe/frischian.py 
from ._utils import check_args
from numpy import log

def demands(lbda,p,alpha,beta,phi,NegativeDemands=True):
    """
    Given marginal utility of income lbda and prices, 
    returns a list of $n$ quantities demanded, conditional on 
    preference parameters (alpha,beta,phi).
    """
    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    x=[((alpha[i]/(p[i]*lbda))**beta[i] - phi[i]) for i in range(n)]

    if not NegativeDemands:
        x=[max(x[i],0.) for i in range(n)]        

    return x

def indirect_utility(lbda,p,alpha,beta,phi,NegativeDemands=True):
    """
    Returns value of Frisch Indirect Utility function
    evaluated at (lbda,p) given preference parameters (alpha,beta,phi).
    """
    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    x=demands(lbda,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    U=0
    for i in range(n):
        if beta[i]==1:
            U += alpha[i]*log(x[i]+phi[i])
        else:
            U += alpha[i]*((x[i]+phi[i])**(1-1./beta[i])-1)*beta[i]/(beta[i]-1)

    return U

V = indirect_utility 

#+END_SRC

* Marshallian demand interface
#+name: marshallian
#+BEGIN_SRC python :tangle ../cfe/marshallian.py 
from . import frischian
from ._core import lambdavalue
from ._utils import check_args, derivative
from numpy import array

"""
Marshallian characterization of the CFE demand system taking budget and prices. 
"""

def demands(y,p,alpha,beta,phi,NegativeDemands=True):

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    lbda=lambdavalue(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    return frischian.demands(lbda,p,alpha,beta,phi,NegativeDemands=NegativeDemands)


def indirect_utility(y,p,alpha,beta,phi,NegativeDemands=True):
    """
    Returns utils associated with income y and prices p.
    """

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    lbda=lambdavalue(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    return frischian.V(lbda,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

V = indirect_utility

def expenditures(y,p,alpha,beta,phi,NegativeDemands=True):

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)
    
    x=demands(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    px=array([p[i]*x[i] for i in range(n)])

    try:
        assert abs(sum(px) - y) < 0.001
    except AssertionError: # Call to all debugging
        lambdavalue(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)        
    
    return px

def budgetshares(y,p,alpha,beta,phi,NegativeDemands=True):
    
    n,alpha,beta,phi = check_args(p,alpha,beta,phi)
    
    x=expenditures(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    w=array([x[i]/y for i in range(n)])

    assert abs(sum(w)-1)<0.001
    
    return w

def share_income_elasticity(y,p,alpha,beta,phi,NegativeDemands=True):
    """
    Expenditure-share elasticity with respect to total expenditures.
    """

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    def w(xbar):
        return budgetshares(xbar,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    dw=derivative(w)

    return [dw(y)[i]*(y/w(y)[i]) for i in range(n)]

def income_elasticity(y,p,alpha,beta,phi,NegativeDemands=True):

    return array(share_income_elasticity(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands))+1.0

#+END_SRC

* Hicksian demand interface
#+name: hicksian
#+BEGIN_SRC python :tangle ../cfe/hicksian.py 
from . import frischian
from ._utils import check_args
from ._core import lambdaforU
from numpy import array

def expenditurefunction(U,p,alpha,beta,phi,NegativeDemands=True):

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    x=demands(U,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    return sum(array([p[i]*x[i] for i in range(n)]))

def demands(U,p,alpha,beta,phi,NegativeDemands=True):

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)
    lbda=lambdaforU(U,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    return frischian.demands(lbda,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

def budgetshares(U,p,alpha,beta,phi,NegativeDemands=True):

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)
    
    h=demands(U,p,alpha,beta,phi,NegativeDemands=NegativeDemands)
    y=expenditurefunction(U,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    return array([p[i]*h[i]/y for i in range(n)])
#+END_SRC    
    
#+name: main
#+BEGIN_SRC python :tangle ../cfe/test/test_demands.py 
from cfe.demands import lambdavalue, marshallian, hicksian, derivative
from numpy import array

def main(y,p,alpha,beta,phi,NegativeDemands=True):

    n=len(p)
    print('lambda=%f' % lambdavalue(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands))
    print('budget shares '+'%6.5f\t'*n % tuple(marshallian.budgetshares(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)))
    print('share income elasticities '+'%6.5f\t'*n % tuple(marshallian.share_income_elasticity(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)))
    print('indirect utility=%f' % marshallian.indirect_utility(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands))
    
    # Here's a test of the connections between different demand
    # representations:
    print("Testing identity relating expenditures and indirect utility...", end=' ')
    V=marshallian.indirect_utility(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)
    X=hicksian.expenditurefunction(V,p,alpha,beta,phi,NegativeDemands=NegativeDemands)
    assert abs(y-X)<1e-6
    print("passed.")
    
    def V(xbar):
        return marshallian.indirect_utility(xbar,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    dV=derivative(V)

    tol=1e-6

    print("Evaluating lambda-V'...", end=' ')
    lbda=lambdavalue(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)
    assert (abs(dV(y)-lbda)<tol), "dV=%f; lambda=%f" % (dV(y),lbda)
    print("within tolerance %f" % tol)

if __name__=="__main__":
    print("Single good; negative phi")
    main(3.,[1],[1],[1],[-2.],NegativeDemands=False)

    print("Passed.")
    print()

    print("Two goods; phis of different signs; no negative demands")
    main(3,[1]*2,[1]*2,[1]*2,[2,-2.],NegativeDemands=False)

    print("Passed.")
    print()

    print("Two goods; phis of different signs; negative demands allowed")
    main(3,[1]*2,[1]*2,[1]*2,[2,-2.],NegativeDemands=True)

    print("Passed.")
    print()

    y=6
    p=array([10.0,15.0])
    alpha=array([0.25,0.75])
    beta=array([1./2,2.])
    phi=array([-.1,0.0])

    main(y,p,alpha,beta,phi)
#+END_SRC    
