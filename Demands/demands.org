:SETUP:
#+TITLE: Code and Methods for Computing Constant Frisch Elasticity Demand Systems
#+AUTHOR: Ethan Ligon
#+OPTIONS: toc:nil
#+PROPERTY: header-args:python :results output :noweb no-export :exports code :comments link :prologue (format "# Tangled on %s" (current-time-string))
#+LATEX_HEADER: \renewcommand{\vec}[1]{\boldsymbol{#1}}
#+LATEX_HEADER: \newcommand{\T}{\top}
#+LATEX_HEADER: \newcommand{\E}{\ensuremath{\mbox{E}}}
#+LATEX_HEADER: \newcommand{\R}{\ensuremath{\mathbb{R}}}
#+LATEX_HEADER: \newcommand{\Cov}{\ensuremath{\mbox{Cov}}}
#+LATEX_HEADER: \newcommand{\Eq}[1]{(\ref{eq:#1})}
#+LATEX_HEADER: \newcommand{\Fig}[1]{Figure \ref{fig:#1}} \newcommand{\Tab}[1]{Table \ref{tab:#1}}
#+LATEX_HEADER: \addbibresource{main.bib}\renewcommand{\refname}{}
#+LATEX_HEADER: \addbibresource{ligon.bib}
#+LATEX_HEADER: \usepackage{stringstrings}\renewcommand{\cite}[1]{\caselower[q]{#1}\citet{\thestring}}
:END:

* Top-level demand interface

Dependencies:
 - demands ::
     - frischian
     - hicksian
     - marshallian
     - _core.lambdavalue
     - _utils.derivative
     - numpy.log
 - _core :: 
     - frischian 
     - hicksian.expenditures 
     - _utils.check_args
 - _utils ::
     - root_with_precision
 - frischian ::
     - _utils.check_args
 - marshallian ::
     - _utils.check_args
     - _core.lambdavalue
     - _utils.derivative

#+name: demands
#+BEGIN_SRC python :tangle ../cfe/demands.py
import . frischian
import . hicksian
import . marshallian
from ._core import lambdavalue, relative_risk_aversion, excess_expenditures, excess_expenditures_derivative, excess_utility, lambdaforU, expenditures
from ._utils import derivative
from numpy import array
#+END_SRC
   
* Core routines
#+name: demand_core
#+BEGIN_SRC python :tangle ../cfe/_core.py
  from . import frischian
  from . import hicksian
  from ._utils import check_args, derivative
  import warnings
  from numpy import nan, Inf
  from .root_with_precision import root_with_precision

  def excess_expenditures(y,p,alpha,beta,phi,NegativeDemands=True):
      """
      Return a function which will tell excess expenditures associated with a lambda.
      """
      n,alpha,beta,phi = check_args(p,alpha,beta,phi)
      n = len(p)

      def f(lbda):
          lbda=abs(lbda)

          x=frischian.demands(lbda,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

          d=0.0
          for i in range(n):
              d += x[i]*p[i]

          return d - y

      return f

  def excess_expenditures_derivative(p,alpha,beta,phi):
      """
      Return derivative of excess expenditures function with respect to lambda
      """
      n,alpha,beta,phi = check_args(p,alpha,beta,phi)
      n = len(p)
      d=beta

      def df(lbda):

          lbda=abs(lbda)
          y=0.0
          for i in range(n):
              y += -d[i]*p[i]*(alpha[i]/(p[i]))**(d[i])*lbda**-(1+d[i])

          return y 

      return df

  def excess_utility(U,p,alpha,beta,phi,NegativeDemands=True):
      """
      Return a function which will tell excess utility associated with a lambda.
      """

      n,alpha,beta,phi = check_args(p,alpha,beta,phi)
      n = len(p)
      def f(lbda):

          return U - frischian.V(lbda,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

      return f

  def lambdavalue(y,p,alpha,beta,phi,NegativeDemands=True,ub=10,method='root_with_precision'):
      """
      Given income y, prices p and preference parameters
      (alpha,beta,phi), find the marginal utility of income lbda.
      """

      n,alpha,beta,phi = check_args(p,alpha,beta,phi)

      if NegativeDemands:
          subsistence=sum([p[i]*phi[i] for i in range(n)])
      else:
          subsistence=sum([p[i]*phi[i] for i in range(n) if phi[i]<0])
      
      if y+subsistence<0: # Income too low to satisfy subsistence demands
          warnings.warn('Income too small to cover subsistence phis (%f < %f)' % (y,subsistence))
          return nan

      f = excess_expenditures(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

      if method=='bisect':
          try:
              return optimize.bisect(f,1e-20,ub)
          except ValueError:
              return lambdavalue(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands,ub=ub*2.0)
      elif method=='newton':
          df = excess_expenditures_derivative(p,alpha,beta,phi)
          return optimize.newton(f,ub/2.,fprime=df)
      elif method=='root_with_precision':
          return root_with_precision(f,[0,ub,Inf],1e-13,open_interval=True)
      else:
          raise ValueError("Method not defined.")

  def lambdaforU(U,p,alpha,beta,phi,NegativeDemands=True,ub=10):
      """
      Given level of utility U, prices p, and preference parameters
      (alpha,beta,phi), find the marginal utility of income lbda.
      """

      n,alpha,beta,phi = check_args(p,alpha,beta,phi)

      f = excess_utility(U,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

      # Our root-finder looks within an interval [1e-20,ub].  If root
      # isn't in this interval, optimize.bisect will raise a ValueError;
      # in this case, try again, but with a larger upper bound.
      try:
          #return optimize.bisect(f,1e-20,ub)
          return root_with_precision(f,[0,ub,Inf],1e-12,open_interval=True)
      except ValueError:
          return lambdaforU(U,p,alpha,beta,phi,NegativeDemands=True,ub=ub*2.0)

  def expenditures(lbda,p,alpha,beta,phi,NegativeDemands=True):

      n,alpha,beta,phi = check_args(p,alpha,beta,phi)

      U=frischian.indirect_utility(lbda,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

      return hicksian.expenditurefunction(U,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

  def relative_risk_aversion(p,alpha,beta,phi,NegativeDemands=True,ub=10,method='root_with_precision'):
      """
      Generates function describing (minus) elasticity of lambda w.r.t. expenditures x.

      NB: This is also relative risk aversion.
      """
      n,alpha,beta,phi = check_args(p,alpha,beta,phi)

      lmbda=lambda x: lambdavalue(x,p,alpha,beta,phi,NegativeDemands=True,ub=10,method='root_with_precision')
      dl=derivative(lmbda)

      def rra(x):
          return -dl(x)/lmbda(x)*x

      return rra
#+END_SRC

* Utility and optimization routines
#+name: demand_utils
#+BEGIN_SRC python :tangle ../cfe/_utils.py
from scipy import optimize 
from numpy import array, ones, zeros, sum, log, Inf, dot, nan, all
import warnings

def check_args(p,alpha,beta,phi):
    """
    Perform sanity check on inputs.  Supply default values if these are missing.
    """

    # Make sure all args are of type array:
    p=array(p,dtype=float)

    try: 
        len(alpha) # If len() not defined, then must be a singleton
        alpha=array(alpha,dtype=float)
    except TypeError: alpha=array([alpha],dtype=float)

    try:
        len(beta) # If len() not defined, then must be a singleton
        beta = array(beta,dtype=float)
    except TypeError: beta = array([beta],dtype=float)

    try:
        len(phi) # If len() not defined, then must be a singleton
        phi=array(phi,dtype=float)
    except TypeError: phi=array([phi],dtype=float)

    n=len(p)

    if len(alpha)==1<n:
        alpha=ones(n)*alpha
    else:
        if not alpha.all():
            raise ValueError

    if len(beta)==1<n:
        beta = ones(n)*beta
    else:
        if not beta.all():
            raise ValueError
        if not all(beta>0):
            raise ValueError
    
    if len(phi)==1<n:
        phi=ones(n)*phi

    return (n,alpha,beta,phi)

def derivative(f,h=2e-5,LIMIT=False):
    """
    Computes the numerical derivative of a function with a single scalar argument.

    - h :: A precision parameter.  

    BUGS: Would be better to actually take a limit, instead of assuming that h 
    is infinitesimal.  
    """
    def df(x, h=h):
        return ( f(x+h/2) - f(x-h/2) )/h
    return df
#+END_SRC

* Frischian demand interface
#+name: frischian
#+BEGIN_SRC python :tangle ../cfe/frischian.py 
from ._utils import check_args
from numpy import log

def demands(lbda,p,alpha,beta,phi,NegativeDemands=True):
    """
    Given marginal utility of income lbda and prices, 
    returns a list of $n$ quantities demanded, conditional on 
    preference parameters (alpha,beta,phi).
    """
    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    x=[((alpha[i]/(p[i]*lbda))**beta[i] - phi[i]) for i in range(n)]

    if not NegativeDemands:
        x=[max(x[i],0.) for i in range(n)]        

    return x

def indirect_utility(lbda,p,alpha,beta,phi,NegativeDemands=True):
    """
    Returns value of Frisch Indirect Utility function
    evaluated at (lbda,p) given preference parameters (alpha,beta,phi).
    """
    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    x=demands(lbda,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    U=0
    for i in range(n):
        if beta[i]==1:
            U += alpha[i]*log(x[i]+phi[i])
        else:
            U += alpha[i]*((x[i]+phi[i])**(1-1./beta[i])-1)*beta[i]/(beta[i]-1)

    return U

V = indirect_utility 


#+END_SRC

* Marshallian demand interface
#+name: marshallian
#+BEGIN_SRC python :tangle ../cfe/marshallian.py 
from . import frischian
from ._core import lambdavalue
from ._utils import check_args, derivative
from numpy import array

def demands(y,p,alpha,beta,phi,NegativeDemands=True):

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    lbda=lambdavalue(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    return frischian.demands(lbda,p,alpha,beta,phi,NegativeDemands=NegativeDemands)


def indirect_utility(y,p,alpha,beta,phi,NegativeDemands=True):
    """
    Returns utils associated with income y and prices p.
    """

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    lbda=lambdavalue(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    return frischian.V(lbda,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

V = indirect_utility

def expenditures(y,p,alpha,beta,phi,NegativeDemands=True):

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)
    
    x=demands(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    px=array([p[i]*x[i] for i in range(n)])

    try:
        assert abs(sum(px) - y) < 0.001
    except AssertionError: # Call to all debugging
        lambdavalue(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)        
    
    return px

def budgetshares(y,p,alpha,beta,phi,NegativeDemands=True):
    
    n,alpha,beta,phi = check_args(p,alpha,beta,phi)
    
    x=expenditures(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    w=array([x[i]/y for i in range(n)])

    assert abs(sum(w)-1)<0.001
    
    return w

def share_income_elasticity(y,p,alpha,beta,phi,NegativeDemands=True):
    """
    Expenditure-share elasticity with respect to total expenditures.
    """

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    def w(xbar):
        return budgetshares(xbar,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    dw=derivative(w)

    return [dw(y)[i]*(y/w(y)[i]) for i in range(n)]

def income_elasticity(y,p,alpha,beta,phi,NegativeDemands=True):

    return array(share_income_elasticity(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands))+1.0

#+END_SRC

* Hicksian demand interface
#+name: hicksian
#+BEGIN_SRC python :tangle ../cfe/hicksian.py 
from . import frischian
from ._utils import check_args
from ._core import lambdaforU
from numpy import array

def expenditurefunction(U,p,alpha,beta,phi,NegativeDemands=True):

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)

    x=demands(U,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    return sum(array([p[i]*x[i] for i in range(n)]))

def demands(U,p,alpha,beta,phi,NegativeDemands=True):

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)
    lbda=lambdaforU(U,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    return frischian.demands(lbda,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

def budgetshares(U,p,alpha,beta,phi,NegativeDemands=True):

    n,alpha,beta,phi = check_args(p,alpha,beta,phi)
    
    h=demands(U,p,alpha,beta,phi,NegativeDemands=NegativeDemands)
    y=expenditurefunction(U,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    return array([p[i]*h[i]/y for i in range(n)])
#+END_SRC    
    
#+name: main
#+BEGIN_SRC python :tangle ../cfe/demands.py 
def main(y,p,alpha,beta,phi,NegativeDemands=True):

    n=len(p)
    print('lambda=%f' % lambdavalue(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands))
    print('budget shares '+'%6.5f\t'*n % tuple(marshallian.budgetshares(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)))
    print('share income elasticities '+'%6.5f\t'*n % tuple(marshallian.share_income_elasticity(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)))
    print('indirect utility=%f' % marshallian.indirect_utility(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands))
    
    # Here's a test of the connections between different demand
    # representations:
    print("Testing identity relating expenditures and indirect utility...", end=' ')
    V=marshallian.indirect_utility(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)
    X=hicksian.expenditurefunction(V,p,alpha,beta,phi,NegativeDemands=NegativeDemands)
    assert abs(y-X)<1e-6
    print("passed.")
    
    def V(xbar):
        return marshallian.indirect_utility(xbar,p,alpha,beta,phi,NegativeDemands=NegativeDemands)

    dV=derivative(V)

    tol=1e-6

    try:
        print("Evaluating lambda-V'...", end=' ')
        lbda=lambdavalue(y,p,alpha,beta,phi,NegativeDemands=NegativeDemands)
        assert abs(dV(y)-lbda)<tol
        print("within tolerance %f" % tol)
    except AssertionError:
        print("dV=%f; lambda=%f" % (dV(y),lbda))

if __name__=="__main__":
    print("Single good; negative phi")
    main(3.,[1],[1],[1],[-2.],NegativeDemands=False)

    print("Passed.")
    print()

    print("Two goods; phis of different signs; no negative demands")
    main(3,[1]*2,[1]*2,[1]*2,[2,-2.],NegativeDemands=False)

    print("Passed.")
    print()

    print("Two goods; phis of different signs; negative demands allowed")
    main(3,[1]*2,[1]*2,[1]*2,[2,-2.],NegativeDemands=True)

    print("Passed.")
    print()

    y=6
    p=array([10.0,15.0])
    alpha=array([0.25,0.75])
    beta=array([1./2,2.])
    phi=array([-.1,0.0])

    main(y,p,alpha,beta,phi)
#+END_SRC    
