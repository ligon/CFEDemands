#    -*- mode: org -*-


Archived entries from file /home/ligon/Research/CFEDemands/Empirics/regression.org


* Estimate
:PROPERTIES:
:ARCHIVE_TIME: 2022-11-25 Fri 10:19
:ARCHIVE_FILE: ~/Research/CFEDemands/Empirics/regression.org
:ARCHIVE_CATEGORY: regression
:END:
#+begin_src python
def estimation(y,d,K=None,bootstrap_tol=None,return_se=False,rectify=False,verbose=False):

    if K is not None:
        d,MdMpy = kmean_controls(K,Mp(y),Mp(d),classifiers=d.loc[:,d.dtypes == 'category'])
        MdMp = lambda x: Md_generator(x,d,Mp=True)
        Md = lambda x: Md_generator(x,d,Mp=False)
        method = 'categorical'
    else:
        method = 'linear'

        # Change categorical vars to numeric
        cats = d.select_dtypes(['category']).columns
        if len(cats):
            d[cats] = d[cats].apply(lambda x: x.cat.codes)

        MdMp = lambda x: Md_generator(x,d,method=method,Mp=True)
        Md = lambda x: Md_generator(x,d,method=method,Mp=False)

        MdMpy = MdMp(y)

    assert MdMpy.index.names == ['i','t','m','j']

    if not np.all(np.abs(MdMpy.groupby(['j','t','m']).mean()) < 1e-6):
        warn('MdMpy means greater than 1e-6')


    # Estimation
    hatb,hatMpw,seb,mults,mults_se,e1 = estimate_beta_and_Mpw(y,MdMp,return_se=return_se,bootstrap_tol=bootstrap_tol,verbose=verbose)

    if verbose: print('Estimating gamma...')
    hatgamma, gamma_d, e2 = estimate_gamma(Mp(y),hatb,hatMpw,d,method=method)
    try:
        if d.columns.name is None:
            d.columns.name = 'k'
    except AttributeError:
        pass

    # y - hatgamma(d)
    y0 = (Mpi(y) - Mpi(gamma_d)).dropna()

    if verbose: print('Estimating w...')

    hatw, Ar, Ar_se, e3 = estimate_w(y0,hatb)
    #print('Ar,w')

    if verbose: print('Estimating pi...')

    hatpi, pi_se, e4 = estimate_pi(y,hatb,hatw,Ar,gamma_d)

    if verbose: print('Predicting y...')
    yhat = predict_y(hatpi,Ar,gamma_d,hatb,hatw)
    e = y - yhat.reindex_like(y)

    sigma2 = e.unstack('j').var()

    R2 = 1 - sigma2/y.unstack('j').var()

    if method=='linear':
        try:
            se_gamma = 1/np.sqrt((d.groupby('j').count()*(d.groupby('j').var() + d.groupby('j').mean()**2)).divide(sigma2,level='j',axis=0))
        except KeyError:  # d doesn't vary with j?
            se_gamma = np.sqrt((outer(sigma2,1/((d.var()+d.mean()**2)*d.count()))))
    else:
        se_gamma = None

    if rectify:
        if verbose: print('Rectifying...')
        B,X = validate(y,hatpi,Ar,d,hatw,hatb,hatgamma,GramSchmidt=False)
        # Re-orthogonalize
        hatb = hatb*B['bw']
        if seb is not None:
            seb = seb*B['bw']
        Ar = Ar*B['Ar']
        Ar_se = Ar_se*B['Ar']
        hatpi = hatpi*(B['pi']@y.groupby('j').count()/y.shape[0])
        pi_se = pi_se*(B['pi']@y.groupby('j').count()/y.shape[0])
        try:
            hatgamma = (hatgamma.stack()*B['gamma_d']).unstack('k')
            if se_gamma is not None:
                se_gamma = (se_gamma.stack()*B['gamma_d']).unstack('k')
        except AttributeError:
            hatgamma = hatgamma*B['gamma_d']
            if se_gamma is not None:
                se_gamma = se_gamma*B['gamma_d']
    else:
        B = None
        X = None

    # Convert tuples in index  to strings (necessary for persistence in sql)
    if hatgamma.index.name == 'tau':
        hatgamma.index = [str(s) for s in hatgamma.index]
        hatgamma.index.name = 'k'

    if return_se:
        mults_se = mults_se.unstack('m')
        pi_se = pi_se.unstack('m')
        Ar_se = Ar_se.unstack(['t','m'])
    else:
        mults_se = None
        pi_se = None
        Ar_se = None

    return dict(y=y,
                yhat=yhat,
                mse=(e**2).mean(),
                R2=R2,
                d=d,
                beta=hatb,
                beta_se=seb,
                mults = mults.unstack('m'),
                mults_se = mults_se,
                e1 = e1,
                w = hatw,
                e3 = e3,
                Mpw = hatMpw,
                gamma = hatgamma,
                gamma_se = se_gamma,
                e2 = e2,
                gamma_d = gamma_d,
                pi = hatpi.unstack('m'),
                pi_se = pi_se,
                e4 = e4,
                Ar = Ar.unstack(['t','m']),
                Ar_se = Ar_se,
                B=B,
                X=X)
#+end_src


* Estimation of $\gamma(d)$
:PROPERTIES:
:ARCHIVE_TIME: 2023-10-10 Tue 19:55
:ARCHIVE_FILE: ~/Research/CFEDemands/Empirics/regression.org
:ARCHIVE_OLPATH: Generally available functions
:ARCHIVE_CATEGORY: regression
:END:
#+name: code:gamma
#+begin_src python :tangle no
def estimate_gamma(y,beta,w,d,method='categorical',verbose=False):
    """
    Estimate $gamma(d) = E[Y| d]$.
    """
    if beta is not None:
        e = y.unstack('j') - pd.DataFrame({0:w})@pd.DataFrame({0:beta}).T
    else:
        e = y.unstack('j')

    if method=='categorical':
        gamma = Mp(e).join(tau,how='left').groupby('tau').mean()
        gamma.columns.name = 'j'

        # Construct gamma(d)
        gamma_d = pd.DataFrame(tau).join(gamma,on='tau')
        gamma_d.columns.name = 'j'
        gamma_d = gamma_d.drop('tau',axis=1)
        gamma_d = gamma_d.stack()
        gamma_d.name = 'gamma_d'

        e = e.stack('j')
    elif method=='linear':
        e = e.stack('j')
        tau['Constant'] = 1

        foo = pd.DataFrame(e).join(tau,how='outer')

        gamma = foo.groupby('j').apply(lambda y,x=tau.columns: ols(y.droplevel('j'),x))
        if gamma.columns.name is None:
            gamma.columns.name = 'k'

        try:
            gamma_d = (tau*gamma).sum(axis=1).dropna()
        except ValueError:
            gamma_d = (tau@gamma.T).stack()

        gamma_d.name = 'gamma_d'
    else: raise ValueError("No method %s." % method)

    #e2 = e - gamma_d.loc[e.index]
    e2 = e - gamma_d.reindex_like(e)

    return gamma, gamma_d, e2

#+end_src


* Estimate
:PROPERTIES:
:ARCHIVE_TIME: 2023-10-10 Tue 19:55
:ARCHIVE_FILE: ~/Research/CFEDemands/Empirics/regression.org
:ARCHIVE_CATEGORY: regression
:END:
#+begin_src python :tangle no
import time

def estimation(y,d,K=None,beta=None,bootstrap_tol=None,return_se=False,rectify=False,verbose=False):

    if K is None: method = 'linear'
    else: method = 'categorical'

    if verbose:
        tic = time.time()
        print('Estimating MpMdy...')

    MpMdy,Md,MpMd,d = estimate_MpMdy(y,d,K)

    if verbose:
        toc = time.time()
        print(f'[{toc-tic}] Estimating beta...')
        tic = toc

    if beta is None:# Estimate b
        hatb,seb,V = estimate_beta(MpMdy,
                                   return_se=return_se,
                                   bootstrap_tol=bootstrap_tol,
                                   verbose=verbose)
    else:
        hatb = beta
        seb = None

    if verbose:
        toc = time.time()
        print(f'[{toc-tic}] Estimating Mpw...')
        tic = toc

    if return_se and bootstrap_tol is None:
        hatMpw, scale, mults, seb, mults_se, e1 = estimate_Mpw(y,hatb,MpMdy,return_se=True)
    else:
        hatMpw,scale,mults = estimate_Mpw(y,hatb,MpMdy,return_se=False)
        mults_se = mults*np.nan
        e1 = None

    # Scale bhat to match up with Mpw normalization
    hatb = (hatb*scale).squeeze()

    if verbose:
        toc = time.time()
        print(f'[{toc-tic}] Estimating gamma...')
        tic = toc

    gamma_d,hatgamma, gamma_d, e2 = estimate_gamma(Mp(y),hatb,hatMpw,d,method=method)
    try:
        if d.columns.name is None:
            d.columns.name = 'k'
    except AttributeError:
        pass

    # y - hatgamma(d)
    y0 = (Mpi(y - gamma_d)).dropna()

    if verbose:
        toc = time.time()
        print(f'[{toc-tic}] Estimating w, Ar...')
        tic = toc

    hatw, Ar, Ar_se, e3 = estimate_w(y0,hatb,verbose=verbose)
    #print('Ar,w')

    if verbose:
        toc = time.time()
        print(f'[{toc-tic}] Estimating pi...')
        tic = toc

    hatpi, pi_se, e4 = estimate_pi(y,hatb,hatw,Ar,gamma_d,verbose=verbose)

    if verbose:
        toc = time.time()
        print(f'[{toc-tic}] Estimating yhat...')
        tic = toc

    yhat = predict_y(hatpi,Ar,gamma_d,hatb,hatw)
    e = y - yhat.reindex_like(y)

    sigma2 = e.unstack('j').var()

    R2 = 1 - sigma2/y.unstack('j').var()

    if verbose:
        toc = time.time()
        print(f'[{toc-tic}] Estimating gamma_se...')
        tic = toc

    if method=='linear':
        try:
            se_gamma = 1/np.sqrt((d.groupby('j').count()*(d.groupby('j').var() + d.groupby('j').mean()**2)).divide(sigma2,level='j',axis=0))
        except KeyError:  # d doesn't vary with j?
            se_gamma = np.sqrt((outer(sigma2,1/((d.var()+d.mean()**2)*d.count()))))
    else:
        se_gamma = None

    if rectify:
        if verbose:
            toc = time.time()
            print(f'[{toc-tic}] Rectifying...')
            tic = toc

        B,X = validate(y,hatpi,Ar,d,hatw,hatb,hatgamma,GramSchmidt=False)
        # Re-orthogonalize
        hatb = hatb*B['bw']
        if seb is not None:
            seb = seb*B['bw']
        Ar = Ar*B['Ar']
        Ar_se = Ar_se*B['Ar']
        hatpi = hatpi*(B['pi']@y.groupby('j').count()/y.shape[0])
        pi_se = pi_se*(B['pi']@y.groupby('j').count()/y.shape[0])
        try:
            hatgamma = (hatgamma.stack()*B['gamma_d']).unstack('k')
            if se_gamma is not None:
                se_gamma = (se_gamma.stack()*B['gamma_d']).unstack('k')
        except AttributeError:
            hatgamma = hatgamma*B['gamma_d']
            if se_gamma is not None:
                se_gamma = se_gamma*B['gamma_d']
    else:
        B = None
        X = None

    if verbose:
        toc = time.time()
        print(f'[{toc-tic}] Finishing...')
        tic = toc

    # Convert tuples in index  to strings (necessary for persistence in sql)
    if hatgamma.index.name == 'tau':
        hatgamma.index = [str(s) for s in hatgamma.index]
        hatgamma.index.name = 'k'

    if return_se:
        mults_se = mults_se.unstack('m')
        pi_se = pi_se.unstack('m')
        Ar_se = Ar_se.unstack(['t','m'])
    else:
        mults_se = None
        pi_se = None
        Ar_se = None

    return dict(y=y,
                yhat=yhat,
                mse=(e**2).mean(),
                R2=R2,
                d=d,
                beta=hatb,
                beta_se=seb,
                beta_V=V,
                mults = mults,
                mults_se = mults_se,
                e1 = e1,
                w = hatw,
                e3 = e3,
                Mpw = hatMpw,
                gamma = hatgamma,
                gamma_se = se_gamma,
                e2 = e2,
                gamma_d = gamma_d,
                pi = hatpi,
                pi_se = pi_se,
                e4 = e4,
                Ar = Ar,
                Ar_se = Ar_se,
                B=B,
                X=X)
#+end_src

